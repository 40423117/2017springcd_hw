var tipuesearch = {"pages":[{"title":"About","tags":"misc","text":"2017Spring 機械設計工程系協同產品設計實習 課程倉儲: http://github.com/mdecourse/2017springcd 課程投影片: http://mdecourse.github.io/2017springcd 課程網誌: http://mdecourse.github.io/2017springcd/blog","url":"./pages/about/"},{"title":"[Week 18] 期末總整理","tags":"Course","text":"[Week 18] 期末總整理 有鑒於方便資料整合，故將期中後到期末的筆記統整成一篇文章，方便其他同學能夠利用最少的時間，學到期中後到期末這幾週老師的課程內容。 課程內容概要整理 [Week 10] 第十週課程內容概要整理。 點我看 將w10資料夾增加到data下，導入add.py，利用Brython顯示出來 [Week 12] 第十二週課程內容概要整理。 點我看 利用Brython繪製正齒輪嚙合 (17t-11t-13t)的圖 [Week 13] 第十三週課程內容概要整理。 點我看 利用Brython繪製正齒輪嚙合 (17t-13t-11t-14t)的圖 [Week 15] 第十五週課程內容概要整理。 點我看 800x600 為畫布大小, 在畫布正中央畫一個半徑為 250 , 壓力角 20, 齒數為 36 齒, 且只有上半齒形的漸開線正齒輪輪廓 建立第二個 800x600 的畫布, 請畫出只有一齒輪廓, 且充滿畫布 80% 範圍的正齒輪, 且該齒輪廓下方水平線, 連接兩端齒根圓點交的直線以紅色繪製, 且在齒輪下方以藍色字元寫上自己的學號 由最右邊齒數 16 齒開始囓合, 依序增加 2 齒, 當排至平面四齒囓合後, 第五位組員則以垂直方向向下囓合兩個齒輪後, 轉由右至左水平排列 [Week 16] Fossil 作業上傳 點我看 使用 Fossil 將作業檔案上傳 [Week 17] 第十七週課程內容概要整理。 點我看 以下各任務操作過程, 請以 ShareX 錄成 mp4, 以\"學號-2017springcd-final-1.mp4 ~ 學號-2017springcd-final-7.mp4\" 命名, 分別送到個人的 Youtube, Vimeo 與 Fossil SCM. 在各自的倉儲中, 建立一個雙足 solvepace 機構零組件, 存入 final 子目錄中 在各自的網誌上, 以 \"W17 行走機構 2D 靜態繪圖\"為標題, 以 Brython 畫出行走機構的示意圖. 在各自的倉儲中, 將 https://github.com/scrum-1/cdbw17 倉儲納入作為 w17 子目錄, 並設法導入其中的 script1.py 進行 axises() 繪圖函式的呼叫, 在任務 2 的圖中畫出座標軸. 在各自的網誌中設法動態顯示出任務 1 所完成的零組件. 將任務 1 所完成的行走機構匯入 V-rep, 並設法模擬雙足機構作動過程. 請在網誌中, 以\"期末分組專題\"為標題, 說明在分組行走機構模擬與實作過程中所扮演的角色, 並說明所負責完成的任務. 各組以協同方式整合各組組員所完成的倉儲, 網誌與操作影片後, 以學號名稱當作子目錄, 其中放入各組員上述各題所完成的操作影片後, 上傳到各組在系上的 Fossil SCM 倉儲, 並設法用各組的 Github Pages 進行分組簡報. 歷史紀錄： [懶人包] 期中前要做的事 影片頻道 Youtube 頻道期中後到期末總整理 全集： 點我看 Vimeo 歷史紀錄： 點我看 歷史 OnShape 教學： 點我看 補充 [期末分組專題] [Final] axises繪圖函式呼叫 W17 行走機構 2D 靜態繪圖 [Fossil 上傳方式]","url":"./week18.html"},{"title":"[Week 17] 期末協同查驗與自評","tags":"Course","text":"[Week 17] 第十七週課程內容概要整理。 以下各任務操作過程, 請以 ShareX 錄成 mp4, 以\"學號-2017springcd-final-1.mp4 ~ 學號-2017springcd-final-7.mp4\" 命名, 分別送到個人的 Youtube, Vimeo 與 Fossil SCM. 在各自的倉儲中, 建立一個雙足 solvepace 機構零組件, 存入 final 子目錄中 在各自的網誌上, 以 \"W17 行走機構 2D 靜態繪圖\"為標題, 以 Brython 畫出行走機構的示意圖. 在各自的倉儲中, 將 https://github.com/scrum-1/cdbw17 倉儲納入作為 w17 子目錄, 並設法導入其中的 script1.py 進行 axises() 繪圖函式的呼叫, 在任務 2 的圖中畫出座標軸. 在各自的網誌中設法動態顯示出任務 1 所完成的零組件. 將任務 1 所完成的行走機構匯入 V-rep, 並設法模擬雙足機構作動過程. 請在網誌中, 以\"期末分組專題\"為標題, 說明在分組行走機構模擬與實作過程中所扮演的角色, 並說明所負責完成的任務. 各組以協同方式整合各組組員所完成的倉儲, 網誌與操作影片後, 以學號名稱當作子目錄, 其中放入各組員上述各題所完成的操作影片後, 上傳到各組在系上的 Fossil SCM 倉儲, 並設法用各組的 Github Pages 進行分組簡報. (已按照順序排序) Youtube_105_2_期中後到期末清單整理 第一項 在各自的倉儲中, 建立一個雙足 solvepace 機構零組件, 存入 final 子目錄中 Videos：40423117-2017springcd-final-1 all.slvs all.stl all_vrep.ttt leg.slvs foot.slvs bar.slvs 第二項 ( W17 行走機構 2D 靜態繪圖 ) 在各自的網誌上, 以 \"W17 行走機構 2D 靜態繪圖\"為標題, 以 Brython 畫出行走機構的示意圖. Videos：40423117-2017springcd-final-2 快速連結[完整文章]： W17 行走機構 2D 靜態繪圖 第三項 ( Final axises繪圖函式呼叫 ) 在各自的倉儲中, 將 https://github.com/scrum-1/cdbw17 倉儲納入作為 w17 子目錄, 並設法導入其中的 script1.py 進行 axises() 繪圖函式的呼叫, 在任務 2 的圖中畫出座標軸. Videos：40423117-2017springcd-final-3 我們可以查看到 cdbw17 中倉儲的 default branch 僅有 master，且老師要求的 w17子目錄則在 master分支下，以下的程式碼，則表示我們要追蹤子模組中的 master分支。 git submodule add -b master https://github.com/scrum-1/cdbw17.git cdbw17 快速連結[完整文章]： Final axises繪圖函式呼叫 第四項 在各自的網誌中設法動態顯示出任務 1 所完成的零組件. Videos：40423117-2017springcd-final-4 window.onload = function(){ var madeleine = new Madeleine({ target: 'target', // target div id data: './../final/all.stl', // data path path: './../data/madeleine/src/' // path to source directory from current html file }); }; 上述展示程式碼: window.onload = function(){ var madeleine = new Madeleine({ target: 'target', // target div id data: './../final/all.stl', // data path path: './../data/madeleine/src/' // path to source directory from current html file }); }; 第五項 將任務 1 所完成的行走機構匯入 V-rep, 並設法模擬雙足機構作動過程. Videos：40423117-2017springcd-final-5 第六項 ( 期末分組專題 ) 請在網誌中, 以\"期末分組專題\"為標題, 說明在分組行走機構模擬與實作過程中所扮演的角色, 並說明所負責完成的任務. 協同部分：40423117 我負責設計部分零組件 40423117-2017springcd-final-6 組裝點我觀看 快速連結[完整文章]： 期末分組專題 第七項 ( Week 16 Fossil 作業上傳 ) 各組以協同方式整合各組組員所完成的倉儲, 網誌與操作影片後, 以學號名稱當作子目錄, 其中放入各組員上述各題所完成的操作影片後, 上傳到各組在系上的 Fossil SCM 倉儲, 並設法用各組的 Github Pages 進行分組簡報. Videos：40423117-2017springcd-final-7 Videos：40423117-2017springcd-final-7_fossil 快速連結[完整文章]： Week 16 Fossil 作業上傳","url":"./week17.html"},{"title":"W17 行走機構 2D 靜態繪圖","tags":"Course","text":"[W17 行走機構 2D 靜態繪圖] 建立一個雙足 solvepace 機構零組件, 以 \"W17 行走機構 2D 靜態繪圖\"為標題, 使用 Brython 畫出行走機構的示意圖. window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../cdbw17/w17']}); } 將 Snap 轉為 Brython 物件畫出行走機構的示意圖 from browser import window from browser import document # 將 Snap 轉為 Brython 物件 snap = window.Snap.new s = snap(\"#svgout\") # 建立物件時, 同時設定 id 名稱 # callback 函式 def onSVGLoaded(data): g.append(data) g = s.group().attr({'id': 'tux'}) # 利用 window.Snap.load 載入 svg 檔案 tux = window.Snap.load(\"./../final/all.svg\", onSVGLoaded) g.transform('t0,20') 上述繪圖程式碼: from browser import window from browser import document # 將 Snap 轉為 Brython 物件 snap = window.Snap.new s = snap(\"#svgout\") # 建立物件時, 同時設定 id 名稱 # callback 函式 def onSVGLoaded(data): g.append(data) g = s.group().attr({'id': 'tux'}) # 利用 window.Snap.load 載入 svg 檔案 tux = window.Snap.load(\"./../final/all.svg\", onSVGLoaded) g.transform('t0,20') from browser import document as doc from browser import html import math # 準備繪圖畫布 canvas = doc[\"two_foot\"] ctx = canvas.getContext(\"2d\") #繪製第一隻腳 ctx.beginPath() ctx.moveTo(180,420) ctx.lineTo(320,480) ctx.lineTo(345.714,420) ctx.lineTo(303.688,401.999) ctx.lineTo(435.261,153.022) ctx.lineTo(387.984,128.037) ctx.lineTo(256.441,377.004) ctx.lineTo(207.424,356.01) ctx.lineTo(180,420) ctx.fillStyle=\"black\" ctx.fill() #繪製第二隻腳 ctx.beginPath() ctx.moveTo(406.02,128.666) ctx.lineTo(357.119,150.3) ctx.lineTo(471.046,407.819) ctx.lineTo(424.218,433.268) ctx.lineTo(457.46,494.438) ctx.lineTo(591.29,421.709) ctx.lineTo(560.121,364.353) ctx.lineTo(519.947,386.185) ctx.lineTo(406.02,128.666) ctx.fillStyle=\"red\" ctx.fill() 上述繪圖程式碼: from browser import document as doc from browser import html import math # 準備繪圖畫布 canvas = doc[\"two_foot\"] ctx = canvas.getContext(\"2d\") #繪製第一隻腳 ctx.beginPath() ctx.moveTo(180,420) ctx.lineTo(320,480) ctx.lineTo(345.714,420) ctx.lineTo(303.688,401.999) ctx.lineTo(435.261,153.022) ctx.lineTo(387.984,128.037) ctx.lineTo(256.441,377.004) ctx.lineTo(207.424,356.01) ctx.lineTo(180,420) ctx.fillStyle=\"black\" ctx.fill() #繪製第二隻腳 ctx.beginPath() ctx.moveTo(406.02,128.666) ctx.lineTo(357.119,150.3) ctx.lineTo(471.046,407.819) ctx.lineTo(424.218,433.268) ctx.lineTo(457.46,494.438) ctx.lineTo(591.29,421.709) ctx.lineTo(560.121,364.353) ctx.lineTo(519.947,386.185) ctx.lineTo(406.02,128.666) ctx.fillStyle=\"red\" ctx.fill()","url":"./week17_2d.html"},{"title":"[Final] axises繪圖函式呼叫","tags":"Course","text":"[W17 行走機構 2D 靜態繪圖] 在各自的倉儲中, 將 https://github.com/scrum-1/cdbw17 倉儲納入作為 w17 子目錄, 並設法導入其中的 script1.py 進行 axises() 繪圖函式的呼叫, 在任務 2 的圖中畫出座標軸. 講解： 把外部的倉庫 clone 到你的子目錄中，通過 git submodule add 的命令將外部專案加為子模組，並命名為cdbw17。 git submodule add -b gh-pages https://github.com/scrum-1/cdbw17.git cdbw17 將原先設定共用程式路徑的位置，改到我們子模組 cdbw17中的w17程式路徑。 ./../cdbw17/w17 ./ 為我們當前的目錄，在blog底下。故我們需退一個目錄在進到cdbw17中，則需 ./../ 我們先看看 script1.py 中的程式是怎麼寫的。 from browser import document import math # 準備繪圖畫布 ''' canvas = document[\"canvas1\"] ctx = canvas.getContext(\"2d\") ''' def axises(ctx): ctx.beginPath() # 設定線的寬度為 5 個單位 ctx.lineWidth = 5 # 將畫筆移動到 (0, 0) 座標點 ctx.moveTo(0, 0) # 然後畫直線到 (100, 0) 座標點 ctx.strokeStyle = \"red\" ctx.lineTo(100, 0) ctx.lineTo(90, 10) ctx.stroke() ctx.closePath() ctx.beginPath() # 畫右上左下的斜線 ctx.moveTo(0, 0) ctx.strokeStyle = \"green\" ctx.lineTo(0, 100) ctx.lineTo(10, 90) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 #ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() ''' axises(ctx) # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (100, 100) 座標點 ctx.moveTo(100, 100) # 然後畫直線到 (150, 200) 座標點 ctx.lineTo(150, 200) # 畫右上左下的斜線 ctx.moveTo(150, 100) ctx.lineTo(100, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() ''' 必須加入這段，才會在我們剛剛設定的共用程式路徑底下，尋找 script1.py 這個檔案導入我們的程式中。 import script1 剛剛設定的共用程式路徑 window.onload=function(){ // 設定 ./../cdbw17/w17 為共用程式路徑 brython({debug:1, pythonpath:['./../cdbw17/w17']}); } 導入程式之後，我們要執行老師要的呼叫axises(ctx)函式，畫座標軸，光只有打 axises(ctx) 是無法執行的，故我們必須打 script1.axises(ctx) 呼叫 script1 模組中的 axises(ctx)函式 ，才能完整執行。 成果展示 window.onload=function(){ // 設定 ./../cdbw17/w17 為共用程式路徑 brython({debug:1, pythonpath:['./../cdbw17/w17']}); } from browser import document as doc from browser import html import math import script1 # 準備繪圖畫布 canvas = doc[\"two_foot\"] ctx = canvas.getContext(\"2d\") script1.axises(ctx) ctx.beginPath() ctx.moveTo(180,420) ctx.lineTo(320,480) ctx.lineTo(345.714,420) ctx.lineTo(303.688,401.999) ctx.lineTo(435.261,153.022) ctx.lineTo(387.984,128.037) ctx.lineTo(256.441,377.004) ctx.lineTo(207.424,356.01) ctx.lineTo(180,420) ctx.fillStyle=\"black\" ctx.fill() ctx.beginPath() ctx.moveTo(406.02,128.666) ctx.lineTo(357.119,150.3) ctx.lineTo(471.046,407.819) ctx.lineTo(424.218,433.268) ctx.lineTo(457.46,494.438) ctx.lineTo(591.29,421.709) ctx.lineTo(560.121,364.353) ctx.lineTo(519.947,386.185) ctx.lineTo(406.02,128.666) ctx.fillStyle=\"red\" ctx.fill() 上述繪圖程式碼: from browser import document as doc from browser import html import math import script1 # 準備繪圖畫布 canvas = doc[\"two_foot\"] ctx = canvas.getContext(\"2d\") script1.axises(ctx) ctx.beginPath() ctx.moveTo(180,420) ctx.lineTo(320,480) ctx.lineTo(345.714,420) ctx.lineTo(303.688,401.999) ctx.lineTo(435.261,153.022) ctx.lineTo(387.984,128.037) ctx.lineTo(256.441,377.004) ctx.lineTo(207.424,356.01) ctx.lineTo(180,420) ctx.fillStyle=\"black\" ctx.fill() ctx.beginPath() ctx.moveTo(406.02,128.666) ctx.lineTo(357.119,150.3) ctx.lineTo(471.046,407.819) ctx.lineTo(424.218,433.268) ctx.lineTo(457.46,494.438) ctx.lineTo(591.29,421.709) ctx.lineTo(560.121,364.353) ctx.lineTo(519.947,386.185) ctx.lineTo(406.02,128.666) ctx.fillStyle=\"red\" ctx.fill()","url":"./week17_2d_axis.html"},{"title":"期末分組專題","tags":"Course","text":"[期末分組專題] 第二組_四足機構V-ERP模擬與實作及檔案分享. 四足機構模擬與實作 協同部分：40423117 我負責設計部分零組件 40423117-2017springcd-final-6 組裝點我觀看 檔案分享 Onshape協同與組裝部分 Onshape零組件協同 Onshape零組件組裝 STL檔案，3DP部分 ag2_final_asm.stl ag2_final.stl ag2_final(1).stl ag2_final(2).stl ag2_final(3).stl ag2_final(4).stl ag2_final(5).stl ag2_final(6).stl ag2_final(7).stl ag2_final(8).stl ag2_final(9).stl","url":"./week17_final.html"},{"title":"[Week 16] Fossil 作業上傳","tags":"Course","text":"[Week 16] 第十六週課程內容概要整理。 老師今天要同學，使用 Fossil 將作業檔案上傳 Download fossil → Upload fossil 影片點我觀看 講解： [mkdir]為建立一個名為 cdag2 的資料夾，[cd] 為進去名為 cdag2 的資料夾 [註：cdag2 為我本學期的組別，同學請自行更改] mkdir cdag2 cd cdag2 讓 fossil 能夠自動上傳 [註：cdag2 為我本學期的組別，同學請自行更改] fossil clone https://帳號@mde2a2.kmol.info/cdag2 cdag2.fossil [mkdir]為建立一個名為 fossils 的資料夾，[cd] 為進去名為 fossils 的資料夾 [註：這個資料夾為開啟fossils用] mkdir fossils cd fossils 進到裡面後開啟fossil， 如果沒有此步驟，則cdag2.fossil檔案會跟著上傳哦！ fossil open ./../cdag2.fossil 告訴fossil加入了所有檔案 fossil add . Commit訊息 [註：因在第一步驟fossil clone的設置，Commit完後會自動提交] fossil commit -m \"add final_hw_40423117\" 等待將檔案上傳完畢即可。 Cdag2.html","url":"./week16.html"},{"title":"[Week 15] 課程內容整理","tags":"Course","text":"[Week 15] 第十五週課程內容概要整理。 800x600 為畫布大小, 在畫布正中央畫一個半徑為 250 , 壓力角 20, 齒數為 36 齒, 且只有上半齒形的漸開線正齒輪輪廓 建立第二個 800x600 的畫布, 請畫出只有一齒輪廓, 且充滿畫布 80% 範圍的正齒輪, 且該齒輪廓下方水平線, 連接兩端齒根圓點交的直線以紅色繪製, 且在齒輪下方以藍色字元寫上自己的學號 由最右邊齒數 16 齒開始囓合, 依序增加 2 齒, 當排至平面四齒囓合後, 第五位組員則以垂直方向向下囓合兩個齒輪後, 轉由右至左水平排列 1.800x600 為畫布大小, 在畫布正中央畫一個半徑為 250 , 壓力角 20, 齒數為 36 齒, 且只有上半齒形的漸開線正齒輪輪廓 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"white\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 250 # 齒數 n = 36 # 壓力角 pa = 20 gear36 = Spur(ctx).Gear(x, y, r, n , pa, \"black\") div = doc[\"onegear_div\"] ctx.beginPath() ctx.lineWidth = \"600\" ctx.strokeStyle = \"white\" ctx.moveTo(0,600) ctx.lineTo(800,600) ctx.stroke() ctx.fillStyle = \"#FF0000\" ctx.font = \"30px ScriptS\" ctx.fillText(\"40423117\",(canvas.width)/2-60,(canvas.height)/2-25) ctx.stroke() 2.建立第二個 800x600 的畫布, 請畫出只有一齒輪廓, 且充滿畫布 80% 範圍的正齒輪, 且該齒輪廓下方水平線, 連接兩端齒根圓點交的直線以紅色繪製, 且在齒輪下方以藍色字元寫上自己的學號. from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=17, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear1'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2+2400 r = 8*(canvas.height/2) # 齒數 n = 20 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"black\") ctx.fillStyle = \"#FF0000\" ctx.font = \"30px ScriptS\" ctx.fillText(\"40423117\",(canvas.width)/2-60,(canvas.height)/2+280) ctx.stroke() 由最右邊齒數 16 齒開始囓合, 依序增加 2 齒, 當排至平面四齒囓合後, 第五位組員則以垂直方向向下囓合兩個齒輪後, 轉由右至左水平排列 # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 16 # 第2齒輪齒數 n_g2 = 18 # 第3齒輪齒數 n_g3 = 20 # 第4齒輪齒數 n_g4 = 22 # 第5齒輪齒數 n_g5 = 24 # 第6齒輪齒數 n_g6 = 26 # 第7齒輪齒數 n_g7 = 28 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.6*canvas.width)/(n_g1+n_g2+n_g3+n_g4) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 rp_g4 = m*n_g4/2 rp_g5 = m*n_g5/2 rp_g6 = m*n_g6/2 rp_g7 = m*n_g7/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.05+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.1+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 第4齒輪的圓心座標 x_g4 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g4 = y_g1 # 第5齒輪的圓心座標 x_g5 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g5 = y_g4+rp_g4+rp_g5 # 第6齒輪的圓心座標 x_g6 =x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g6 = y_g5+rp_g5+rp_g6 # 第7齒輪的圓心座標 x_g7 =x_g6-rp_g6-rp_g7 y_g7 = y_g5+rp_g5+rp_g6 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423101 \",x_g1-20, y_g1) ctx.stroke() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423103 \",x_g2-20, y_g2) ctx.stroke() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423104 \",x_g3-20, y_g3) ctx.stroke() # 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g4, y_g4) # rotate to engage ctx.rotate(math.pi/2-math.pi/n_g4+(math.pi+math.pi/n_g3)*n_g3/n_g4*2) # put it back ctx.translate(-x_g4, -y_g4) Spur(ctx).Gear(x_g4, y_g4, rp_g4, n_g4, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423117 \",x_g4-20, y_g4) ctx.stroke() # 將第5齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g5, y_g5) # rotate to engage ctx.rotate(math.pi/2-math.pi/n_g5+(math.pi+math.pi/n_g4)*n_g4/n_g5*2) # put it back ctx.translate(-x_g5, -y_g5) Spur(ctx).Gear(x_g5, y_g5, rp_g5, n_g5, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423136 \",x_g5-20, y_g5) ctx.stroke() # 將第6齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g6, y_g6) # rotate to engage ctx.rotate(math.pi/2-math.pi/n_g6+(math.pi+math.pi/n_g5)*n_g5/n_g6*2) # put it back ctx.translate(-x_g6, -y_g6) Spur(ctx).Gear(x_g6, y_g6, rp_g6, n_g6, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423149 \",x_g6-20, y_g6) ctx.stroke() # 將第7齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g7, y_g7) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g7+(math.pi+math.pi/n_g6)*n_g6/n_g7) # put it back ctx.translate(-x_g7, -y_g7) Spur(ctx).Gear(x_g7, y_g7, rp_g7, n_g7, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423157 \",x_g7-20, y_g7) ctx.stroke()","url":"./week15.html"},{"title":"[Week 13] 課程內容整理","tags":"Course","text":"[Week 13] 第十三週課程內容概要整理。 利用Brython繪製正齒輪嚙合 (17t-13t-11t-14t)的圖 利用漸開線原理, 以 Brython 繪製正齒輪廓: window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"white\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 - 100 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n17 = 17 n11 = 11 n13 = 13 n14 = 14 canvas_size = canvas.height*0.4 r17 = canvas_size*n17/(n17+n11+n13+n14) r11 = canvas_size*n11/(n17+n11+n13+n14) r13 = canvas_size*n13/(n17+n11+n13+n14) r14 = canvas_size*n14/(n17+n11+n13+n14) x17 = x - r17 x11 = x + r11 x13 = x+ 2*r11 + r13 x14 = x+ 2*r11 + r13 y17 = y y11 = y y13 = y y14 = y*2/1.435 # 壓力角 pa = 20 gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, \"black\") gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, \"blue\") gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, \"black\") gear14 = Spur(ctx).Gear(x14, y14, r14, n14, pa, \"blue\") div = doc[\"onegear_div\"]","url":"./week13.html"},{"title":"[Week 12] 課程內容整理","tags":"Course","text":"[Week 12] 第十二週課程內容概要整理。 利用Brython繪製正齒輪嚙合 (17t-11t-13t)的圖 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"black\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"blue\") ctx.restore() # ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"black\") ctx.restore() # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 17 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 13 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm twnr = tweener(0, 90000, \"loop\") cx = canvas.width/2 cy = canvas.height/2 #gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 #cgo.render(gear) # 利用 gear 資料複製一份, 命名為 gear1 gear1 = gear.dup() from time import time from browser.timer import request_animation_frame as raf from browser.timer import set_interval deg = math.pi/180 def draw(): cgo.clearCanvas() gear.rotate(2*deg) # 在特定位置, 以特定 scale, 特定 degs 執行 render cgo.render(gear, {'x':cx-pr/2, 'y':cy, 'scl':0.5, 'degs':0}) gear1.rotate(-2*deg) cgo.render(gear1, {'x':cx+pr*2*0.5-pr/2, 'y':cy, 'scl':0.5, 'degs':0}) set_interval(draw, 2)","url":"./week12.html"},{"title":"[Week 10] 課程內容整理","tags":"Course","text":"[Week 10] 第十週課程內容概要整理。 將w10資料夾增加到data下，導入add.py，利用Brython顯示出來 window.onload=function(){ // 設定 cdw10 為共用程式路徑 brython({debug:1, pythonpath:['./../data/w10']}); } from browser import document as doc from browser import html import math import add container = doc['container'] container2 = doc['container2'] a=1 b=16 sum=add.add(a,b) container <= str(sum) degree = math.pi/180 def button1(event): a = input(\"give me a\") container2 <= str(math.cos(60*degree)+float(a)) doc[\"button1\"].bind(\"click\", button1) 按下取 a 值 程式碼 window.onload=function(){ // 設定 cdw10 為共用程式路徑 brython({debug:1, pythonpath:['./../data/w10']}); } from browser import document as doc from browser import html import math import add container = doc['container'] a=1 b=16 sum=add.add(a,b) container <= str(sum) 加減乘除 def addend (a,b): #加運算 return a+b def minus (a,b): #減運算 return a-b def tines (a,b): #乘運算 return a*b def divided (a,b): #除運算 return a/b 加減乘除程式碼 import sys sys.path.append(\"./w10\") import alldef a=3 b=2 add = alldef.addend (a,b) #加運算 minus = alldef.minus (a,b) #減運算 tines = alldef. tines (a,b) #乘運算 divided = alldef.divided (a,b) #除運算 print('加運算=', add) print('減運算=', minus) print('乘運算=', tines) print('除運算=', divided)","url":"./week10.html"},{"title":"[懶人包] 期中前要做的事","tags":"Course","text":"有鑒於方便資料整合，故將期中之前的筆記統整成一篇文章，方便其他同學能夠利用最少的時間，學到期中前這幾週老師的課程內容。 課程內容概要整理。 [Week 1] 環境建立，可攜系統下載安裝 複習 上學期 的內容 [Week 2] 修改Start.bat，讓程式自動更改stunnel設定檔ip位址 利用solvespace畫出四連桿機構組立 [Week 3] 翻譯 Hyperworker1 、 Hyperworker3 利用solvespace組立及v-rep轉入 Solvespace 輸入三角形頂點運動軌跡 [Week 4] 平面四連桿機構的運動路徑方程式推導與網際 2D 繪圖, 2D 繪圖以 Brython 在各組網誌中完成 使用solvespace繪畫one_link，導入V-REP [Week 5] 利用v-rep設定單連桿運動 [Week 6] 利用solvespace完成四連桿和八連桿的繪製和組裝 將畫好的零件利用v-rep做連桿動作模擬 影片頻道 Youtube 頻道期中總整理 全集： 點我看 Vimeo 歷史紀錄： 點我看 歷史 OnShape 教學： 點我看 補充 設定Github之默認倉儲 解決倉儲推送時，出現之問題 所有檔案下載區 建立工作環境 可攜程式系統(1GB) [Week2] solvespace 零件檔領取 link_30.slvs link_50.slvs link_60.slvs 組立檔 [Week4] solvespace 零件檔領取 base.slvs link.slvs shaft.slvs 組立檔 [Week6] 零件檔領取 link_15.slvs link_39.3.slvs link_39.4.slvs link_50.slvs link_61.9.slvs link_fixed.slvs pin_10.slvs pin_15.slvs triangle_upper.slvs bracket_lower.slvs 8link_組立檔 8link_STL OnShape","url":"./week9_1.html"},{"title":"[Github] Page build failure","tags":"Course","text":"[ 解決倉儲推送時，出現之問題 ] 4/20更新 [Github] 寄信告知問題 信件全文 The page build failed with the following error: 因無法上傳，故此行隱藏，詳情請看圖片 For information on troubleshooting Jekyll see: https://help.github.com/articles/troubleshooting-jekyll-builds If you have any questions you can contact us by replying to this email. 解決辦法 至倉儲資料夾，於 plugin\\liquid_tags 資料夾中的 Readme.md 檔案，將原本的 } 改成 }} 更改後，程式碼如下： # Liquid-style Tags *Author: Jake Vanderplas * This plugin allows liquid-style tags to be inserted into markdown within Pelican documents. Liquid uses tags bounded by ``{{% ... %}}``, and is used to extend markdown in other blogging platforms such as octopress. This set of extensions does not actually interface with liquid, but allows users to define their own liquid-style tags which will be inserted into the markdown preprocessor stream. There are several built-in tags, which can be added as follows. First, in your pelicanconf.py file, add the plugins you want to use: PLUGIN_PATH = '/path/to/pelican-plugins' PLUGINS = ['liquid_tags.img', 'liquid_tags.video', 'liquid_tags.youtube', 'liquid_tags.vimeo', 'liquid_tags.include_code', 'liquid_tags.notebook'] There are several options available ## Image Tag To insert a sized and labeled image in your document, enable the ``liquid_tags.img`` plugin and use the following: {{% img [class name(s)] path/to/image [width [height]] [title text | \"title text\" [\"alt text\"]] %}} ### Base64 Image (inline image) tag There is one more tag for image: ``b64img``. It is based on ``img`` tag, but instead of inserting link on image it acutally reads image and inserts it as base64 text into `` `` will be collapsed when the html page is loaded and can be expanded by clicking on them. Cells containing the comment line ``# `` will be open on load but can be collapsed by clicking on their header. Cells without collapse comments are rendered as standard code input cells. ## Testing To test the plugin in multiple environments we use [tox](http://tox.readthedocs.org/en/latest/), to run the entire test suite, just type: wzxhzdk:0 [IPython]: http://ipython.org/","url":"./week6_1.html"},{"title":"[Week 6] 課程內容整理","tags":"Course","text":"[Week 6] 第六週課程內容概要整理。 利用solvespace完成四連桿和八連桿的繪製和組裝 將畫好的零件利用v-rep做連桿動作模擬 四連桿模擬 solvespace 影片教學 link_30影片 link_50影片 link_60影片 solvespace 零件檔領取 link_30.slvs link_50.slvs link_60.slvs 組立檔 solvespace 繪製到運動模擬 V-rep 運動模擬 八連桿模擬 零件檔領取 link_15.slvs link_39.3.slvs link_39.4.slvs link_50.slvs link_61.9.slvs link_fixed.slvs pin_10.slvs pin_15.slvs triangle_upper.slvs bracket_lower.slvs 8link_組立檔 8link_STL OnShape V-rep 運動模擬","url":"./week6.html"},{"title":"[Week 5] 課程內容整理","tags":"Course","text":"[Week 5] 第五週課程內容概要整理。 利用v-rep設定單連桿運動 使用solvespace繪畫one_link base_tutorial link_tutorial shaft_tutorial 組裝_tutorial V-REP模擬 solvespace 零件檔領取 base.slvs link.slvs shaft.slvs 組立檔 V-rep 單連桿機構模擬","url":"./week5.html"},{"title":"[Week 4] 課程內容整理","tags":"Course","text":"[Week 4] 第四週課程內容概要整理。 平面四連桿機構的運動路徑方程式推導與網際 2D 繪圖, 2D 繪圖以 Brython 在各組網誌中完成 使用solvespace繪畫one_link，導入V-REP 網際平面四連桿機構動態模擬 四連桿平面機構 window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } from browser import window cango = window.Cango2D.new shapedefs = window.shapeDefs obj2d = window.Obj2D.new group2d = window.Group2D.new cgo = cango(\"plotarea\") x1, y1 = 40, 20 cx1, cy1 = 90, 120 x2, y2 = 120, 100 cx2, cy2 = 130, 20 cx3, cy3 = 150, 120 x3, y3 = 180, 60 def dragC1(mousePos): global cx1, cy1 cx1 = mousePos.x cy1 = mousePos.y drawCurve() def dragC2(mousePos): global cx2, cy2 cx2 = mousePos.x cy2 = mousePos.y drawCurve() def dragC3(mousePos): global cx3, cy3 cx3 = mousePos.x cy3 = mousePos.y drawCurve() def drawCurve(): # curve change shape so it must be re-draw each time # draw a quadratic bezier from x1,y2 to x2,y2 qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], \"PATH\", { \"strokeColor\":'blue'}) cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], \"PATH\", { \"strokeColor\":'green'}) # show lines to control point L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"dashed\":[4]}) # semi-transparent gray L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"dashed\":[4]}) L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"dashed\":[4]}) #c1.transform.reset() c1.transform.translate(cx1, cy1) #c2.transform.reset() c2.transform.translate(cx2, cy2) #c3.transform.reset() c3.transform.translate(cx3, cy3) grp = group2d(qbez, cbez, L1, L2, L3, c1, c2, c3) cgo.clearCanvas() cgo.render(grp) cgo.clearCanvas(\"lightyellow\") cgo.setWorldCoords(0, 0, 200) # draggable control points c1 = obj2d(shapedefs.circle(4), \"SHAPE\", {\"fillColor\":'red'}) c1.enableDrag(None, dragC1, None) c2 = c1.dup() c2.enableDrag(None, dragC2, None) c3 = c1.dup() c3.enableDrag(None, dragC3, None) drawCurve(); 平面機構繪圖: from browser import window cango = window.Cango2D.new shapedefs = window.shapeDefs obj2d = window.Obj2D.new group2d = window.Group2D.new cgo = cango(\"plotarea2\") x1, y1 = 40, 20 cx1, cy1 = 90, 120 x2, y2 = 120, 100 cx2, cy2 = 130, 20 cx3, cy3 = 150, 120 x3, y3 = 180, 60 def dragC1(mousePos): global cx1, cy1 cx1 = mousePos.x cy1 = mousePos.y drawCurve() def dragC2(mousePos): global cx2, cy2 cx2 = mousePos.x cy2 = mousePos.y drawCurve() def dragC3(mousePos): global cx3, cy3 cx3 = mousePos.x cy3 = mousePos.y drawCurve() def dragX1(mousePos): global x1, y1 x1 = mousePos.x y1 = mousePos.y drawCurve() def drawCurve(): # curve change shape so it must be re-draw each time # draw a quadratic bezier from x1,y2 to x2,y2 qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], \"PATH\", { \"strokeColor\":'blue'}) cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], \"PATH\", { \"strokeColor\":'green'}) # show lines to control point ''' L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"dashed\":[4]}) # semi-transparent gray L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"dashed\":[4]}) L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"dashed\":[4]}) ''' L1 = obj2d(['M', x1, y1, 'L', cx1, cy1], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"solided\":[10]}) # semi-transparent gray L2 = obj2d(['M', cx1, cy1, 'L', cx2, cy2], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"solided\":[10]}) L3 = obj2d(['M', cx2, cy2, 'L', cx3, cy3], \"PATH\", { \"strokeColor\":\"rgba(0, 0, 0, 0.2)\", \"solided\":[10]}) #c1.transform.reset() c1.transform.translate(cx1, cy1) #c2.transform.reset() c2.transform.translate(cx2, cy2) #c3.transform.reset() c3.transform.translate(cx3, cy3) #mx1.transform.reset() mx1.transform.translate(x1, y1) #grp = group2d(qbez, cbez, L1, L2, L3, c1, c2, c3) grp = group2d(L1, L2, L3, c1, c2, c3, mx1) cgo.clearCanvas() cgo.render(grp) cgo.clearCanvas(\"lightyellow\") cgo.setWorldCoords(0, 0, 200) # draggable control points c1 = obj2d(shapedefs.circle(4), \"SHAPE\", {\"fillColor\":'red'}) c1.enableDrag(None, dragC1, None) c2 = c1.dup() c2.enableDrag(None, dragC2, None) c3 = c1.dup() c3.enableDrag(None, dragC3, None) mx1 = c1.dup() mx1.enableDrag(None, dragX1, None) drawCurve(); 機械手臂動態模擬: from browser import window cango2d = window.Cango2D.new shapedefs = window.shapeDefs obj2d = window.Obj2D.new tweener = window.Tweener.new cgo = cango2d(\"robot\") # 清除畫面 cgo.clearCanvas(\"lightyellow\") cgo.setWorldCoords(-50, -50, 300) # 加上基軸與第一桿 # 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z'] stand = obj2d(standData, \"SHAPE\", { \"fillColor\":'darkgray', \"border\": True, \"strokeColor\": \"#222222\" }) axle0 = obj2d(shapedefs.circle(10), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\" }) armGrp = cgo.createGroup2D(stand, axle0) segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z'] seg1 = obj2d(segData, \"SHAPE\", { \"fillColor\":'darkGray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": -1 }) # 利用 zIndex 決定疊層的先後次序 axle1 = obj2d(shapedefs.circle(8), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": 1 }) axle1.translate(50, 0) seg1Grp = cgo.createGroup2D(seg1, axle1) armGrp.addObj(seg1Grp) # 加上第二軸 seg2 = obj2d(segData, \"SHAPE\", { \"fillColor\":'darkGray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": -1 }) axle2 = obj2d(shapedefs.circle(8), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": 1 }) axle2.translate(50, 0) seg2Grp = cgo.createGroup2D(seg2, axle2) cgo.render(seg2Grp) # 請注意 seg2Grp 加上 seg1Grp 物件上 seg1Grp.addObj(seg2Grp) seg3 = obj2d(segData, \"SHAPE\", { 'fillColor':'darkGray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': -1 }) axle3 = obj2d(shapedefs.circle(6), \"SHAPE\", { 'fillColor':'gray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': 1 }) axle3.translate(50, 0) seg3Grp = cgo.createGroup2D(seg3, axle3) seg2Grp.addObj(seg3Grp) seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z'] seg4 = obj2d(seg4Data, \"SHAPE\", { 'fillColor':'darkGray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': -1 }) seg3Grp.addObj(seg4) # setup animation animData = {'s1': [0, 80, 45, 0], 's2': [0, -60, -60, 0], 's3': [0, -90, 0, 90, 0], 's4': [0, 30, -90, 0]} armTwnr = tweener(0, 3500, 'loop') def initArm(opts): seg2Grp.transform.translate(50,0) seg3Grp.transform.translate(50,0) seg4.transform.translate(50,0) def armPathFn(time, opts): seg1Rot = armTwnr.getVal(time, opts.s1) seg2Rot = armTwnr.getVal(time, opts.s2) seg3Rot = armTwnr.getVal(time, opts.s3) seg4Rot = armTwnr.getVal(time, opts.s4) seg1Grp.transform.rotate(seg1Rot) seg2Grp.transform.rotate(seg2Rot) seg2Grp.transform.translate(50,0) seg3Grp.transform.rotate(seg3Rot) seg3Grp.transform.translate(50,0) seg4.transform.rotate(seg4Rot) seg4.transform.translate(50,0) cgo.animate(armGrp, initArm, armPathFn, animData) cgo.playAnimation() 使用solvespace繪畫one_link base_tutorial link_tutorial shaft_tutorial 組裝_tutorial V-REP模擬 solvespace 零件檔領取 base.slvs link.slvs shaft.slvs 組立檔","url":"./week4.html"},{"title":"[Week 3] 課程內容整理","tags":"Course","text":"[Week 3] 第三週課程內容概要整理。 翻譯 Hyperworker1 、 Hyperworker3 利用solvespace組立及v-rep轉入 Solvespace 輸入三角形頂點運動軌跡 solvespace 影片教學 link_30影片 link_50影片 link_60影片 組立影片 solvespace 零件檔領取 link_30.slvs link_50.slvs link_60.slvs 組立檔 利用solvespace組立及v-rep轉入 SolveSpace組立及v-rep轉入_Tutorial 三角形運動軌跡輸出CSV至EXCEL查看 SolveSpace_W3_Tutorial 105_1_CSVTOEXCEL_Tutorial 105_2_CSVTOEXCEL_Tutorial 先在link_50零件中，於兩個圓心上畫出一個相交的兩條線 尺寸各為50 接著先點選三角形之頂點，接著點選Analyze，再點選Trace Point 任意點選一個點\u0004，讓軌跡運動 接著再點選Analyze，點選 Stop Tracing... 請存成 CSV格式 於EXCEL上，以點建立圖表","url":"./week3.html"},{"title":"[Hyperworker3] 翻譯","tags":"Course","text":"[Week 3] 第三週作業之一 Hyperworker3 翻譯。 In OptiStruct, one of our focus areas is nonlinear large deformation analysis. 在OptiStruct中，我們的一個重點領域是非線性大變形分析。 And in 2017 we added nonlinear transient analysis. 在2017年，我們添加了非線性瞬態分析 The main purpose was to couple AcuSolve to do fluid-structure interaction. 主要目的是使AcuSolve與流體 - 結構相互作用。 But also one development that happened during the last year came out piece-wise in different point releases and is now really mature. 但是，在過去一年中發生的一個發展，在不同的積分發布中分段出現，現在已經成熟。 And 2017 is our contact analysis, so we have different ways of defining sliding contact and things like that. 2017年是我們的接觸分析，所以我們有不同的方式來定義滑動接觸和類似的東西。 The fast contact analysis for small deformation is blazing fast. 對小變形的快速接觸分析是快速的。 It's a very simple idea that makes the solution very fast, and that adds OptiStruct as really a leading nonlinear structural solver. 這是一個非常簡單的想法，使解決方案非常快，並將OptiStruct添加為真正的領先的非線性結構求解器。 Our two major optimization packages are OptiStruct for structural optimization, there's a huge multidisciplinary component, too. 我們的兩個主要優化包是用於結構優化的OptiStruct，還有一個巨大的多學科組件。 And Hyperstudy for general optimization wrap around multidisciplinary optimization. 並且Hyperstudy對一般優化包圍多學科優化。 [For] OptiStruct we spend a lot of time continuing the development for optimization and we have now Failsafe topology optimization. [For] OptiStruct我們花了很多時間繼續開發優化，我們現在已經失效的拓撲優化。 We kept on working on the manufacturing solution to do lattice optimization. 我們一直在製造解決方案上做晶格優化。 For the multi-model optimization it's really maturing and we find more and more applications where that helps. 對於多模型優化，它真的成熟，我們發現越來越多的應用程序，這有助於。 Our goal is actually to include all the physics in the optimizations. 我們的目標實際上是在優化中包括所有的物理。 So the team right now is working on optimization for nonlinear problems and so on. 所以團隊現在正在努力優化非線性問題等等。 And then Hyperstudy, on the other hand, is going through a new transformation of the user the user experience was changed a few years back, but we are now trying to make it much more easy to use by hiding a lot of the advanced functionalities to the regular users. 另一方面，Hyperstudy正在經歷用戶體驗在幾年前改變的用戶體驗的一個新的轉變，但是我們現在試圖通過隱藏許多高級功能來使它更容易使用 普通用戶。 And depending on the level of expertise or depending on the job that the user has to do, they can customize the user experience. 並且取決於專業水平或者根據用戶必須做的工作，他們可以定制用戶體驗。 We adds a few new connections. 我們添加了一些新的連接。 One of them is a Flux connection. 其中一個是Flux連接。 Flux is an electromagnetics code that we just acquired for low frequency electromagnetics, so we can all take a Flux database and put it into Hyperstudy into the study with that. Flux是我們剛剛為低頻電磁學採集的電磁學代碼，所以我們可以採用一個Flux數據庫，並把它放入Hyperstudy進行研究。","url":"./week3_2.html"},{"title":"[Hyperworker1] 翻譯","tags":"Course","text":"[Week 3] 第三週作業之一 Hyperworker1 翻譯。 In the 2017 release, we followed our vision and implement a lot more features, delivering more technology for your HyperWorks units investment. 在2017年版本中，我們遵循了我們的願景並實施了更多功能，為您的HyperWorks單位投資提供更多技術。 In our continuous development, we focused, as# always, on simulation-driven innovation, adding more optimization technology. 在我們的不斷發展中，我們一如既往地專注於模擬驅動的創新，增加更多的優化技術。 We added more physics simulation to the software, and we improved our parallel performance on high performance computers. 我們增加了許多的物理的模擬，我們提高了高性能電腦的平行性能。 OptiStruct, which is our implicit code, adds a lot of development in the nonlinear implicit area, but also in the optimization technology. OptiStruct是我們的隱式代碼，在非線性隱含區域中，也在優化技術中添加了很多開發。 RADIOSS, we see a lot of development in new materials and material modeling. RADIOSS，我們看到很多新材料和材料建模的發展。 You probably know that we did the acquisition of MDS a couple of years back, and we have now MDS integrated with RSDIOSS, and are doing application there. 您可能知道我們在幾年前就完成了MDS的收購，現在我們已經將MDS與RSDIOSS整合，並開始應用。 MotionSolve is based on a very unique formulation that this different from other multibody dynamics code, and the formulation lends itself very well to optimization implementation. MoMotionSolvetionSolve是根據一個非常獨特的公式，這不同於其他多體動力學代碼，MotionSolve公式本身非常好地優化實施。 So the team has worked really hard on contact formulations, got very robust. 因此團隊對於接觸公式非常努力，獲得了非常強大的。 It's very cool which kind of problems can solve with contact modelling. 這類型的問題可以解決與接觸建模這是非常酷的。 So this is along the structural solvers side on AcuSolve side we actually added the complete portfolio of turbulence and transition models that really helps us to solve problems in wind turbines and automotive industry much more accurately, and it's a big asset of physics simulation. 因此，這是沿著AcuSolve一側的結構解算方面，我們實際添加了完整的湍流和轉換模型組合，真正幫助我們更準確地解決風力渦輪機和汽車行業的問題，這是物理仿真的一個重要的資產。 And then our electromagnetic suite has actually grown last year through the acquisition of Flux, from the CEDRAT company. 然後，我們的電磁套件實際上是去年通過從CEDRAT公司收購Flux而實現的。 As well as the acquisition of WinProp, from AWE. 以及從AWE收購WinProp。 So now we have a complete frequency spectrum from low frequency electromagnetics the high frequency electromagnetics which is powered by FEKO. 所以現在我們有一個完整的頻譜從低頻電磁學的高頻電磁學由FEKO供電。 We now have a complete portfolio of physics modeling available for our customers, and it's all linked through optimization. 我們現在有一個完整的物理建模組合可用於我們的客戶，它都通過優化鏈接。","url":"./week3_1.html"},{"title":"[Week 2] 課程內容整理","tags":"Course","text":"[Week 2] 第二週課程內容概要整理。 修改Start.bat，讓程式自動更改stunnel設定檔ip位址 利用solvespace畫出四連桿機構組立 修改Start.bat，讓程式自動更改stunnel設定檔ip位址 修改前(備份)： REM tiny2017 主要針對初學 Python3 與 C 學員所建立 REM 近端使用 fossil 管理資料版本, 並且定時轉為 git 格式後上傳到 github @echo off REM 設定 y 硬碟代號與 data 目錄對應 set Disk=y subst %Disk%: \"data\" REM 設定 leo 相關對應 Home 位置 set HomePath=%Disk%:\\home set HomeDrive=%Disk%:\\home set Home=%Disk%:\\home REM 將系統 Python 程式的 io 設為 utf-8 set PYTHONIOENCODING=\"utf-8\" REM 將後續的指令執行, 以 %Disk% 為主 %Disk%: REM 設定 PYTHONPATH set PYTHONPATH=%Disk%:\\python-3.5.3-embed-amd64 REM 設定 Leo 所用的編輯器 set LEO_EDITOR=%Disk%:\\wscite\\SciTE.exe REM for fossil https 連線設定 set HTTPS=on REM 指令搜尋路徑設定 set path1=%PATH%;%Disk%:;%Disk%:\\python-3.5.3-embed-amd64;%Disk%:\\git\\bin;%Disk%:\\stunnel\\bin;%Disk%:\\sqlite-tools;%Disk%:\\python-3.5.3-embed-amd64\\Scripts;%Disk%:\\portablegit\\bin; path=%path1%; start /MIN %Disk%:\\wscite\\SciTE.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe REM 啟動 Leo 編輯器 REM %Disk%:\\python-3.5.3-embed-amd64\\python.exe %Disk%:\\launchLeo.py REM 啟動 stunnel start /MIN fossil.exe server -P 127.0.0.1:8080 %Disk%:\\tmp\\fossil_repo start /MIN stunnel.exe Exit 修改後： REM tiny2017 主要針對初學 Python3 與 C 學員所建立 REM 近端使用 fossil 管理資料版本, 並且定時轉為 git 格式後上傳到 github @echo off REM 設定 y 硬碟代號與 data 目錄對應 set Disk=y subst %Disk%: \"data\" REM 設定 leo 相關對應 Home 位置 set HomePath=%Disk%:\\home set HomeDrive=%Disk%:\\home set Home=%Disk%:\\home REM 將系統 Python 程式的 io 設為 utf-8 set PYTHONIOENCODING=\"utf-8\" REM 將後續的指令執行, 以 %Disk% 為主 %Disk%: REM 設定 PYTHONPATH set PYTHONPATH=%Disk%:\\python-3.5.3-embed-amd64 REM 設定 Leo 所用的編輯器 set LEO_EDITOR=%Disk%:\\wscite\\SciTE.exe REM for fossil https 連線設定 set HTTPS=on REM 指令搜尋路徑設定 set path1=%PATH%;%Disk%:;%Disk%:\\python-3.5.3-embed-amd64;%Disk%:\\git\\bin;%Disk%:\\stunnel\\bin;%Disk%:\\sqlite-tools;%Disk%:\\python-3.5.3-embed-amd64\\Scripts;%Disk%:\\portablegit\\bin; set path2=c:\\Windows\\Microsoft.NET\\Framework\\v3.5;%Disk%:\\python-3.5.3-embed-amd64\\Lib\\site-packages; set path3=\"C:\\Program Files (x86)\\Google\\Chrome\\Application\" path=%path%;%path1%;%path2%;%path3% start /MIN %Disk%:\\wscite\\SciTE.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe REM 啟動 Leo 編輯器 REM %Disk%:\\Miniconda3\\python.exe %Disk%:\\apps\\launchLeo.py REM 啟動 stunnel start /MIN fossil.exe server -P 127.0.0.1:8080 %Disk%:\\tmp\\fossil_repo\\vcp.fossil REM 取得電腦 IP, 然後設定 %Disk%:/stunnel/config/stunnel.conf for /f \"delims=[] tokens=2\" %%a in ('ping -4 -n 1 %ComputerName% &#94;| findstr [') do set NetworkIP=%%a REM echo Network IP: %NetworkIP% REM Saved in %Disk%:\\stunnel\\config\\stunnel.conf @echo off REM 建立 stunnel.conf @echo [https] > %Disk%:\\stunnel\\config\\stunnel.conf REM 附加資料 @echo accept = %NetworkIP%:443 >> %Disk%:\\stunnel\\config\\stunnel.conf @echo connect = 127.0.0.1:8080 >> %Disk%:\\stunnel\\config\\stunnel.conf @echo TIMEOUTclose = 0 >> %Disk%:\\stunnel\\config\\stunnel.conf @echo cert = %Disk%:\\stunnel\\config\\localhost.crt >> %Disk%:\\stunnel\\config\\stunnel.conf @echo key = %Disk%:\\stunnel\\config\\localhost.key >> %Disk%:\\stunnel\\config\\stunnel.conf REM 啟動 stunnel start /MIN stunnel.exe REM set proxy REG IMPORT setup_proxy.reg REM 以 chrome 連線到 https://%NetworkIP%:443 REM chrome --proxy-server=\"140.130.17.17:3128\" --proxy-bypass-list=\"192.168.1.*;*.edu.tw\" https://%NetworkIP% chrome https://%NetworkIP% http://mde.tw https://mde2a1.kmol.info https://mde2a2.kmol.info https://vimeo.com/user24079973 http://mde.tw/2017springcd/blog/ http://mde.tw/2017springwcm/blog/ http://mde.tw/2017springvcp/blog/ http://service.mde.tw Exit solvespace 影片教學 link_30影片 link_50影片 link_60影片 組立影片 solvespace 零件檔領取 link_30.slvs link_50.slvs link_60.slvs 組立檔","url":"./week2.html"},{"title":"[Github] 默認倉儲設定","tags":"Course","text":"[ 設定Github之默認倉儲 ] 教學影片 [Github] 默認倉儲設定 先進入自己的倉儲後，點選 Setting\u0004 進入 Setting\u0004後，點選 Branch 在Default branch下設定自己想默認的倉儲，這邊預設為 gh-pages 點選 Update 點選 I understand,update the default branch. 回到自己的倉儲後，默認倉儲就是剛剛設定的倉儲","url":"./week1_1.html"},{"title":"[Week 1] 課程內容整理","tags":"Course","text":"[Week 1] 第一週課程內容概要整理。 環境建立，可攜系統下載安裝 複習 上學期 的內容 可攜系統安裝 下載 可攜程式系統(1GB) start.bat 啟動, stop.bat 關閉 建議存在隨身硬碟中使用 登記GITHUB、ONSHAPE 帳號 (利用學校信箱註冊) Github - 已註冊 40423117 OnShape - 已註冊40423117 建立個人作業倉儲 先登入 GitHub Create a new Repository Repository name : 2017springcd_hw 打勾 [Initialize this repository with a README] 按下 Create repository 進入 Setting Set Default branch : gh-pages 錄影工具 (ShareX) 去聲音指令: ffmpeg.exe -i 檔名 -c copy -an out.mp4 字幕指令: ffmpeg.exe -i out.mp4 -vf subtitles=in.srt out2.mp4 Git Code 安裝pelican指令: pip install pelican 新增submodule: git submodule add -b gh-pages 倉儲網址 刪除指令: git rm -rf Clone時連submodule一起下載: git clone --recursive 倉儲網址 Clone完發現submodule是空的時候,用指令抓: git submodule update --init --recursive 子目錄下的子模組一次全部更新(Pull)： git submodule foreach --recursive git pull origin gh-pages Proxy Setting 至區域網路(LAN)設定中，設定Proxy伺服器 位址： proxy.mde.tw 連接埠： 3128 Git Proxy Setting 學校代理主機，在命令提示字元[ cmd.exe ]輸入指令: [http] git config --global http.proxy http://proxy.mde.tw:3128 [https] git config --global https.proxy http://proxy.mde.tw:3128","url":"./week1.html"}]};